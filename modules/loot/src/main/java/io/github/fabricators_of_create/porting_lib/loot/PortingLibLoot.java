package io.github.fabricators_of_create.porting_lib.loot;

import java.util.List;

import com.mojang.serialization.MapCodec;

import com.mojang.serialization.MapCodec;

import io.github.fabricators_of_create.porting_lib.core.PortingLib;
import io.github.fabricators_of_create.porting_lib.loot.extensions.LootTableBuilderExtensions;
import io.github.fabricators_of_create.porting_lib.util.RegistryBuilder;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.event.Event;
import net.fabricmc.fabric.api.loot.v3.LootTableEvents;
import net.fabricmc.fabric.api.resource.ResourceManagerHelper;
import net.minecraft.core.Registry;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.packs.PackType;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.storage.loot.LootContext;

public class PortingLibLoot implements ModInitializer {
	public static final ResourceKey<Registry<MapCodec<? extends IGlobalLootModifier>>> GLOBAL_LOOT_MODIFIER_SERIALIZERS_KEY = PortingLib.key("global_loot_modifier_serializers");
	public static final Registry<MapCodec<? extends IGlobalLootModifier>> GLOBAL_LOOT_MODIFIER_SERIALIZERS = new RegistryBuilder<>(GLOBAL_LOOT_MODIFIER_SERIALIZERS_KEY).create();
	public static final ResourceLocation LAST = PortingLib.id("last");

	@Override
	public void onInitialize() {
		ResourceManagerHelper.get(PackType.SERVER_DATA).registerReloadListener(LootModifierManager.ID, lookup -> {
			LootModifierManager.INSTANCE.injectContext(lookup);
			return LootModifierManager.INSTANCE;
		});
		Registry.register(BuiltInRegistries.LOOT_CONDITION_TYPE, PortingLib.id("loot_table_id"), LootTableIdCondition.LOOT_TABLE_ID);

		LootTableEvents.MODIFY.addPhaseOrdering(Event.DEFAULT_PHASE, LAST);
		LootTableEvents.MODIFY.register(LAST,
				(key, builder, source, provider) -> ((LootTableBuilderExtensions) builder).port_lib$setId(key.location())
		);
	}

	/**
	 * All loot table drops should be passed to this function so that mod added effects
	 * (e.g. smelting enchantments) can be processed.
	 *
	 * @param list The loot generated
	 * @param context The loot context that generated that loot
	 * @return The modified list
	 *
	 * @deprecated Use {@link #modifyLoot(ResourceLocation, ObjectArrayList, LootContext)} instead.
	 *
	 * @implNote This method will use the {@linkplain LootTableIdCondition#UNKNOWN_LOOT_TABLE
	 *           unknown loot table marker} when redirecting.
	 */
	@Deprecated
	public static List<ItemStack> modifyLoot(List<ItemStack> list, LootContext context) {
		return modifyLoot(LootTableIdCondition.UNKNOWN_LOOT_TABLE, ObjectArrayList.wrap((ItemStack[]) list.toArray()), context);
	}

	/**
	 * Handles the modification of loot table drops via the registered Global Loot Modifiers,
	 * so that custom effects can be processed.
	 *
	 * <p>All loot-table generated loot should be passed to this function.</p>
	 *
	 * @param lootTableId The ID of the loot table currently being queried
	 * @param generatedLoot The loot generated by the loot table
	 * @param context The loot context that generated the loot, unmodified
	 * @return The modified list of drops
	 *
	 * @apiNote The given context will be modified by this method to also store the ID of the
	 *          loot table being queried.
	 */
	public static ObjectArrayList<ItemStack> modifyLoot(ResourceLocation lootTableId, ObjectArrayList<ItemStack> generatedLoot, LootContext context) {
		context.setQueriedLootTableId(lootTableId); // In case the ID was set via copy constructor, this will be ignored: intended
		LootModifierManager man = LootModifierManager.INSTANCE;
		for (IGlobalLootModifier mod : man.getAllLootMods()) {
			generatedLoot = mod.apply(generatedLoot, context);
		}
		return generatedLoot;
	}
}
